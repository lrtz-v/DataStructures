# CPU 性能

## 平均负载

- 执行 top 或者 uptime 命令，可以看到如下信息

  - ```bash
    21:40  up 44 days, 49 mins, 3 users, load averages: 2.45 3.11 3.40
    ```

- 信息含义

  - 当前时间
  - 系统运行时间
  - 正在登录用户数
  - 过去 1 分钟、5 分钟、15 分钟的平均负载（Load Average）
    - 简单来说，平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数
      - 可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程
      - 不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程
    - 但它实际上是活跃进程数的指数衰减平均值

- 注意
  - 平均负载高有可能是 CPU 密集型进程导致的
  - 平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了
  - 当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源

## 工具

- stress Linux 系统压力测试工具
  - stress --cpu 1 --timeout 600
  - stress -i 1 --timeout 600
  - stress -c 8 --timeout 600
- sysstat 包含了常用的 Linux 性能工具
  - mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标
    - mpstat -P ALL 5 20
  - pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标
    - mpstat -P ALL 5 20

## 上下文切换

- 进程上下文切换
  - 系统调用，完成从用户态到内核态的转变
    - CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码
    - CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务
    - 而系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换
  - 进程上下文切换
    - 从一个进程切换到另一个进程运行
    - 在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈
    - 进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态
- 线程上下文切换
- 中断上下文切换

## 进程调度时机

- 为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行
- 进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行
- 当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度
- 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行
- 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序
