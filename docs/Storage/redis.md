# Redis

## 数据结构

- String
  - int 8 字节长整型
  - SDS
    - embstr 小于 44 个字节
    - raw 大 44 个字节
- List
  - zipList
  - linkedList
  - quickList
    - 是一个 ziplist 组成的双向链表。每个节点使用 ziplist 来保存数据。
- Hash
  - zipList
  - hashTable
- Set
  - int set
  - hashTable
- Sorted Set
  - skiplist
  - dict 存储 member 对应的 score + skipList 存储根据 score 对 member 的定位结构
- GEO
  - geohash
- HyperLogLog 海量数据统计
- Bitmap
  - bit 数组，统计海量数据

## 事务

- 命令

  - MULTI 开始事务
  - EXEC 提交执行事务
  - DISCARD 取消一个事务，清空客户端的整个事务队列
  - WATCH 在事务开始之前监视任意数量的键，执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务不再执行
    - 维护 watched_keys 字典，用链表表示所有监视这个键的客户端
    - 通过 REDIS_DIRTY_CAS 标示键是否被修改

- ACID

  - 原子性（无）命令不会回滚
  - 一致性

    - 入队错误（一致）：带有不正确入队命令的事务不会被执行，也不会影响数据库的一致性
    - 执行错误（一致）：命令在事务执行的过程中发生错误，这不会引起事务中断或整个失败，不会影响已执行事务命令的结果，也不会影响后面要执行的事务命令
    - Redis： 进程被终结，需要看持久化模式
      - 内存模式：没有采取任何持久化机制，那么重启之后的数据库总是空白的，所以数据总是一致的
      - RDB: Redis 不会中断事务去执行保存 RDB 的工作;恢复数据库使用的 RDB 文件可能不是最新的，但数据库是一致的
      - AOF
        - 如果事务语句未写入到 AOF 文件，还原后的数据库是一致的，但其中的数据不一定是最新的
        - 如果事务的部分语句被写入到 AOF 文件，重启 Redis 时，程序会检测到 AOF 文件并不完整，Redis 会退出并报告错误，

  - 隔离性：单线程自带隔离
  - 持久性：事务的持久性由 Redis 所使用的持久化模式决定
    - 内存模式下，事务肯定是不持久的
    - RDB 模式下的 Redis 事务不保证持久，因为 rdb 不是实时快照
    - AOF 模式下，如果不是每次 fsync ，不能保证持久，但每次 fsync 严重影响性能

## 线程

- AOF 重写
- RDB 生成

## 其他问题

- Redis 字符串与 C 字符串区别

  - redis 的字符串底层数据结构是 sds， 包含 len、free、buf[]
  - 字符串长度获取是 O(1)的
  - 内存分配释放策略
    - len 的值小于 1MB， 会分配和 len 同样大小的空间
    - len 大于等于 1MB，那么程序会分配 1MB 的空间给 free
  - 缓冲区溢出问题
    - 内存预分配策略能有效避免缓冲区溢出问题， C 不行
  - 二进制安全
    - SDS 字符串 API 都是以处理二进制的方式处理 buf 数组里的数据，程序不会对其中的数据进行过滤、操作等，所以 SDS 是二进制数据安全的
    - C 字符串的字符则必须符合某种编码（ASCII），并且字符串的中间不能包含空字符，否则字符串就会被截断，所以 C 字符串只能保存文本数据，而不能保存图片、音视频等数据类型

- redis 链表

  - 应用
    - 事务模块使用双端链表依序保存输入的命令
    - 服务器模块使用双端链表来保存多个客户端
    - 订阅/发送模块使用双端链表来保存订阅模式的多个客户端
    - 事件模块使用双端链表来保存时间事件（time event）
    - 队列数据结构（List）
  - 实现
    - listNode
      - prev
      - value
      - next
    - list
      - head 链表头
      - tail 链表尾
      - len 节点数量
      - dup 复制函数
      - free 释放函数
      - match 对比函数

- redis 字典

  - hashtable
    - Hash 计算
      - 哈希值：hash = dict->type->hashFunction(key);
      - 索引值：index = hash & dict->ht.sizemask;
        - 保证不会发生数组越界， sizemask = size - 1；
        - 保证元素尽可能的均匀分布
  - 渐进式 rehash
    - 为字典的 ht[1] 哈希表分配空间
      - 扩展：ht[1] 的大小为第一个大于等于 ht[0].used \* 2 的 2^n
      - 缩容：大小为第一个大于等于 ht[0].used 的 2^n
    - 每次对字典执行添加、删除、查找或者更新操作时，顺带重新计算 rehashidx 对应键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上
    - 释放 ht[0] ， 将 ht[1] 设置为 ht[0]
  - 触发扩展
    - 服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1
    - 服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5
  - 触发缩容
    - 负载因子小于 0.1
  - 访问
    - 查找：先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找
    - 更新在两个表上都执行
    - 新增只在 ht[1]上

- redis skiplist

  - 使用双向链表存储数据，根据 score 和 ele 排序
  - 建立 32 层 level 辅助查询
  - 为什么不使用平衡树（作者答）
    - 生成层数函数里的概率 p，取决得当的话其实和平衡树差不多
    - 有序集合经常会进行 ZRANGE 或 ZREVRANGE 这样的范围查找操作，跳表里面的双向链表可以十分方便地进行这类操作
    - ZRANK 操作还能达到 O(logN) 的时间复杂度

- 压缩列表

  - 容器对象的元素个数小于一定条件时，redis 会使用 ziplist 的方式储存，来减少内存的使用
  - ziplist 它本身是一块连续的内存块，所以它的读写是 顺序 I/O， 效率高于链表的随机 I/O
  - 双向列表结构
    - zlbytes：压缩列表占用的内存字节数
    - zltail：压缩列表表尾节点的偏移量
    - zllen：节点数量
    - entry[]：节点
      - prevlen：前一个元素的长度
      - encoding
        - 字符串元素：元素的编码+长度
        - 整数：整数类型
    - zlend：特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端

- 过期键删除

  - 定时删除
    - 设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作
  - 惰性删除
    - 每次从键空间中获取键时，检查该键是否过期，如果过期，就删除该键
  - 定期删除
    - 每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响
  - 过期键持久化
    - RDB
      - 已过期的键不会被保存到新创建的 RDB 文件中
      - master 载入 RDB 文件时，过期键会被忽略，slave 则不会
    - AOF
      - 追加一条 DEL 命令
      - 已过期的键不会被保存到重写后的 AOF 文件中

- 内存淘汰机制

  - noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。默认策略
  - allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key
  - allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key
  - volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key
  - volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key
  - volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除

## 集群方案

- 主从
  - 优点
    - 读写分离
    - 异步同步
  - 缺点
    - 不具备自动容错与恢复机制
    - 在线扩容复杂
- 哨兵
  - 优点
    - 基于主从模式
    - master 自动切换
  - 缺点
    - 在线扩容复杂
    - 需要额外资源支持哨兵进程
- Cluster

  - 无中心接口
    - 数据按照 slot 分布在多个节点
    - 所有 redis 节点彼此互联
    - 节点失效通过集群中半数节点检测失效才生效
    - 客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可
  - 工作机制
    - 根据 key 计算 slot，找到 slot 对应的节点
    - 半数以上节点与问题节点通信超时，认为该节点宕机
  - 缺点
    - Smart Client 直连 Redis
    - 仅支持单个节点 Pipeline，不支持跨节点

- 哨兵

  - 工作内容：
    - 监控：监控着 redis 的 master 和 slave 进程是否是在正常工作
    - 消息通知：发现有 redis 实例有故障的话，就会发送消息给管理员
    - 故障自动转移：如果 redis master 节点宕机了的话，它就会将请求转到 slave 节点上，slave 升为 master，将 master 的新地址写在配置中心告诉客户端
  - 数据丢失
    - 数据还没有复制到 slave 中，master 就挂掉了
    - master 与 slave 网络中断，哨兵选出新的 master
    - 解决方法
      - min-slaves-to-write 1 # 要求至少一个 slave
      - min-slaves-max-lag 10 # 数据复制和同步的延迟不能超过 10s
        - slave 超过 10 秒没有给自己返回 ack 消息，master 就会拒绝客户端的写请求
  - 宕机
    - sdown，即主观宕机，如果一个哨兵它自己觉得 master 宕机了，就是主观宕机
    - odown，即客观宕机，如果 quorum 数量的哨兵都认为一个 master 宕机了，则为客观宕机
  - 选举算法
    - slave 升级需要考虑的信息
      - 跟 master 断开连接的时长， 断开时间超过 down-after-milliseconds 十倍的 slave 不适合
      - slave 优先级排序
      - 复制 offset，复制了越多的数据优先级越高
      - run id，优先选选择一个 run id 比较小的 slave

- 命令执行过程

  - redis 建立事件机制 eventLoop， 注册周期时间事件处理器
  - 服务器会为每个客户端链接创建一个 Client 对象，并创建相应文件事件来监听 socket 的可读事件，并指定事件处理函数
  - 从 socket 中读取数据到输入缓冲区中，解析并获得命令，执行命令并将返回值存储到输出缓冲区中
  - 将命令结果写入输出缓冲区
  - 将命令返回值从输出缓冲区写入 socket

- LRU

  - 按访问时间排序，发生淘汰的时候，把访问时间最旧的淘汰掉
  - redisObject 记录了最后一次的访问时间（分钟）及命中频次
  - 随机采样若干个 key，将 idle time 大与缓冲池 idle time 的 key 放入缓冲池
  - 需要删除时，从缓冲池删除 idle time 大的 key

- LFU
  - 按频次排序，一个数据被访问过，把它的频次+1，发生淘汰的时候，把频次低的淘汰掉
  - 频次统计
    - 概率量级计数
      - 每一次 key 被访问，counter 都有概率会+1，节省空间
    - 计数衰减：针对热点数据
      - 根据衰减周期-1
    - 新增数据赋值
      - 新 key 的默认值 LFU_INIT_VAL
  - 过程
    - 采用抽样+回收池

## Redis 对比 Etcd
