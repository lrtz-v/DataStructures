# 弹力设计

## 系统可用性

- Availability = MTTF / (MTTF + MTTR)
- MTTF: 平均故障前时间(正常运行时间)
- MTTR: 平均修复时间

## 隔离设计 （Bulkheads）

### 隔离方法

- 按照业务隔离
- 按照用户隔离

### 优缺点

- 使用完全的隔离方案，在开发实现上和资源隔离度方面会非常好，但成本比较高且计算资源会有一定的浪费
- 使用完全共享的方案，资源利用很成非常好，但开发难度大，数据和资源隔离非常不好
- 一般会使用折中的方案，服务是共享的，数据通过分区隔离，需要更好的隔离性则使用完全隔离
- 然而，随着虚拟化技术的成熟，我们完全可以使用“完全隔离”，通过虚拟化技术实现物理资源的共享和成本的节约

### 重点

- 定义好隔离业务的大小和粒度，需要结合业务和系统分析
- 无论采用什么隔离方案，都需要考虑复杂度、成本、性能问题，明确需要什么不需要什么
- 隔离模式需要配置一些高可用、重试、异步、消息中间件、流控、熔断等设计模式的方式配套使用
- 自动化运维
- 监控

## 异步通讯（Asynchronous）

- 系统解耦合之后会面临很多问题，其中就有系统间的通讯

### 同步

- 同步调用链的性能由最慢的那个服务所决定
- 对于高并发系统，一层一层的同步调用会极大的消耗资源
- 同步调用是一对一的，很难做到一对多
- 如果被调用方又问题，调用方就会又问题

### 异步

#### 异步通讯方式

- 请求响应式：sender调用receiver，receiver立即返回并异步处理，sender采用轮训的方式检查处理结果；或者receiver通过回调通知任务处理状态
- 订阅：sender将消息发送到receiver订阅的队列，receiver从队列获取消息，sender不关心消息处理结果（接收方要向发送方订阅消息，接收方依赖订阅方，有一定的耦合）
- Broker：sender和receiver都看不到对方，只能看到Broker，sender向Broker发送消息，receiver从Broker订阅消息（完全解耦）。Broker需要是：高可用、高性能且支持水平扩展、持久化

#### 事件驱动设计（EDA Event Driven Architecture）

##### 优点

- 服务间的依赖没有了，服务是平等的，并高度可重用且可替换
- 服务的开发、测试、运维、故障处理都是高度隔离的
- 服务间通过事件关联，所以服务间不会相互block
- 在服务间增加Adapter（日志、认证、监控、限流、熔断等）较容易
- 服务吞肚被解开了，各服务按照自己的处理速度处理

##### 缺点

- 业务流程不再那么明显和好管理，整个架构会变得比较复杂。需要有一些可视化工具来呈现整个业务流程
- 事件可能会乱序，需要很好的管理一个状态机的控制
- 事务处理变得复杂，需要使用两阶段提交来做强一致性，或退缩到最终一致性

#### 异步通讯的设计重点

- 异步通讯最重要的是解耦服务间的依赖，最佳方式是通过Broker
- 解耦的目标是使各个服务的隔离性更好
- 异步通讯的架构可以获得更大的吞吐量，且各服务性能不受干扰
- 使用Broker或队列的方式可以把抖动的吞吐量变成均匀的吞吐量，即“削峰”
- 服务相对独立，开发、测试、运维、故障处理都是高度隔离的

- 异步通讯的中间件Broker需要设计成高可用不丢消息的，因为是分布式，所以消息的顺序无法保证，故设计最好不依赖消息的顺序
- 异步通讯会导致业务流程不那么直观，Broker需要有相关的消息跟踪机制
- 服务间只通过消息交互，所以业务状态最好由一个总控方管理，以便在系统故障后知道业务处理到哪一步，从而继续处理
- 消息处理中的ACK和幂等

## 幂等性设计（Idempotency）

- 一次和多次请求应该具有同样的副作用：f(x) = f(f(x))

### 全局ID

- Snowflake

### HTTP的幂等

- 幂等：GET、PUT、OPTIONAL、DELETE
- 非幂等：POST
- POST中可以通过PRG（Post／Redirect／Get）做幂等

## 服务中的状态（State）

### 无状态

- 方便扩展和运维
- 降低代码复杂度
- 状态需要保存到其他地方，不太重要的数据可以保存在Redis中，重要的数据保存在Mysql中，或ZooKeeper／Etcd这样的高可用的强一致性的存储，或者分布式文件系统（如Ceph／GlusterFS）
- 需要耦合第三方有状态的存储服务，会存在依赖并增加网络开销
- 第三方的存储服务需要做成高可用高扩展的方式，并增加缓存

### 有状态

- 数据本地化：状态和数据保存在本机，延迟低，对于数据密集型服务会更快
- 更高的可用性和更高的一致性：CAP中的C和A
- 通过长连接和hash确定节点，但节点的负载和数据不均匀，（骚操作：反向压力（Back Pressure））
- 解决负载： 通过Gossip协议，在各节点之间散播消息来同步元数据，新增或减少节点时集群内部较容易重新分配
- 业界方案：Facebook的Scuba（分布式内存数据库）；Uber的Ringpop（根据地理位置分片的路由请求库）；微软的Orlans（Halo 4就是基于它的）

### 服务状态的容错处理

- 很多高可用的设计都采用数据在运行时就复制的方案，如：Zookeeper、kafka、Redis、ES
- 强一致性的系统一般采用两阶段提交

## 补偿事物（Compensating Transaction）

### CAP

- 一致性（Consistency）
- 可用性（Availability）
- 分区容忍性（Partition Tolerance）

### ACID（保证数据库的一致性）

- 原子性：整个事物中的所有操作，要么全部成功，要么全失败，不可能停滞在中间某个环节；事务执行期间发生错误，会被回滚到事务执行前的状态
- 一致性：在事务开始前和事务结束之后，数据库的完整性约束没有被破坏
- 隔离性：两个事务的执行是互不干扰的，一个事务不可能看到另一个事务执行时中间某一时刻的数据
- 持久性：事务执行完成后，该事务对数据库的变更便持久的保存在数据库中，并不会被回滚

### BASE

- Basic Availability：基本可用，意味着系统可以出现暂时不可用的状态，而后面会快速恢复
- Soft-State：软状态，它是“有状态”和“无状态”的服务的一种中间状态；即，为提高性能，允许服务暂时保存一定的状态和数据（非强一致性）
- Eventual Consistency：最终一致性，系统在一个短暂的时间内是不一致的，但最终系统看到的数据是一致的

### 总结

- ACID 强调的是一致性（C），BASE强调可用性（A）

### 业务补偿的设计重点

- 因为要把一个业务流程执行完成，需要流程中涉及的服务支持幂等，并且在上游有重试机制
- 使用工作流引擎维护和监控整个过程的状态
- 补偿的业务逻辑和流程有时可以并行
- 需清楚，业务补偿的业务逻辑是强业务相关的，很难通用
- 下层的业务方最好提供短期的资源预留机制

## 重试（Retry）

### 设计重点

- 确定什么错误下需要重试
- 重试时间与重试次数
- 超过重试次数之后，新来的请求直接返回错误就好了（熔断）
- 要考虑被调用方是否有幂等处理
- 重试的代码应该做到不侵入业务代码

## 熔断设计（Circuit Breaker）

### 使用状态及时间熔断器

- 闭合（Closed）：调用失败，失败计数加一，在给定时间内失败率达到阀值，则切换到断开状态（Open）；此时开启超时始终，过期后切换到半开状态（Half-Open）
- 断开（Open）：请求会立即返回错误，或者cache住上次返回成功的值，直接返回缓存
- 半开（Half-Open）：允许一定量的请求调用后端服务，若调用成功，将状态改为闭合状态，计数器重置；若有调用失败的情况，则切回断开状态

### 熔断设计重点

- 确认熔断错误类型
- 日志监控
- 测试服务或否可用：对远程服务定期健康检查，减少对用户请求的影响
- 手动操作
- 并发问题：熔断器面临高并发请求
- 资源分区：熔断隔离
- 重试错误的请求：记录失败的请求及参数，在半开状态下重试请求判断服务是否恢复，需要被调用端支持幂等

### 解决案例

- https://github.com/Netflix/Hystrix https://github.com/Netflix/Hystrix/wiki/How-it-Works#CircuitBreaker

## 限流设计（Throttle）

### 限流行为

- 拒绝服务：拒绝暴增流量
- 服务降级
- 特权请求：降级不重要业务，保证关键链路
- 延时处理：通过队列缓冲请求，队列满了之后返回错误
- 弹性伸缩：通过自动化运维对服务自动化伸缩

### 限流实现方式



