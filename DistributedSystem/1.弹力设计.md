# 弹力设计

## 系统可用性

- Availability = MTTF / (MTTF + MTTR)
- MTTF: 平均故障前时间(正常运行时间)
- MTTR: 平均修复时间

## 隔离设计 （Bulkheads）

### 隔离方法

- 按照业务隔离
- 按照用户隔离

### 优缺点

- 使用完全的隔离方案，在开发实现上和资源隔离度方面会非常好，但成本比较高且计算资源会有一定的浪费
- 使用完全共享的方案，资源利用很成非常好，但开发难度大，数据和资源隔离非常不好
- 一般会使用折中的方案，服务是共享的，数据通过分区隔离，需要更好的隔离性则使用完全隔离
- 然而，随着虚拟化技术的成熟，我们完全可以使用“完全隔离”，通过虚拟化技术实现物理资源的共享和成本的节约

### 重点

- 定义好隔离业务的大小和粒度，需要结合业务和系统分析
- 无论采用什么隔离方案，都需要考虑复杂度、成本、性能问题，明确需要什么不需要什么
- 隔离模式需要配置一些高可用、重试、异步、消息中间件、流控、熔断等设计模式的方式配套使用
- 自动化运维
- 监控

## 异步通讯（Asynchronous）

- 系统解耦合之后会面临很多问题，其中就有系统间的通讯

### 同步

- 同步调用链的性能由最慢的那个服务所决定
- 对于高并发系统，一层一层的同步调用会极大的消耗资源
- 同步调用是一对一的，很难做到一对多
- 如果被调用方又问题，调用方就会又问题

### 异步

#### 异步通讯方式

- 请求响应式：sender调用receiver，receiver立即返回并异步处理，sender采用轮训的方式检查处理结果；或者receiver通过回调通知任务处理状态
- 订阅：sender将消息发送到receiver订阅的队列，receiver从队列获取消息，sender不关心消息处理结果（接收方要向发送方订阅消息，接收方依赖订阅方，有一定的耦合）
- Broker：sender和receiver都看不到对方，只能看到Broker，sender向Broker发送消息，receiver从Broker订阅消息（完全解耦）。Broker需要是：高可用、高性能且支持水平扩展、持久化

#### 事件驱动设计（EDA Event Driven Architecture）

##### 优点

- 服务间的依赖没有了，服务是平等的，并高度可重用且可替换
- 服务的开发、测试、运维、故障处理都是高度隔离的
- 服务间通过事件关联，所以服务间不会相互block
- 在服务间增加Adapter（日志、认证、监控、限流、熔断等）较容易
- 服务吞肚被解开了，各服务按照自己的处理速度处理

##### 缺点

- 业务流程不再那么明显和好管理，整个架构会变得比较复杂。需要有一些可视化工具来呈现整个业务流程
- 事件可能会乱序，需要很好的管理一个状态机的控制
- 事务处理变得复杂，需要使用两阶段提交来做强一致性，或退缩到最终一致性

#### 异步通讯的设计重点

- 异步通讯最重要的是解耦服务间的依赖，最佳方式是通过Broker
- 解耦的目标是使各个服务的隔离性更好
- 异步通讯的架构可以获得更大的吞吐量，且各服务性能不受干扰
- 使用Broker或队列的方式可以把抖动的吞吐量变成均匀的吞吐量，即“削峰”
- 服务相对独立，开发、测试、运维、故障处理都是高度隔离的

- 异步通讯的中间件Broker需要设计成高可用不丢消息的，因为是分布式，所以消息的顺序无法保证，故设计最好不依赖消息的顺序
- 异步通讯会导致业务流程不那么直观，Broker需要有相关的消息跟踪机制
- 服务间只通过消息交互，所以业务状态最好由一个总控方管理，以便在系统故障后知道业务处理到哪一步，从而继续处理
- 消息处理中的ACK和幂等

## 幂等性设计（Idempotency）





