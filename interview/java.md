# Java

## 基础题目

- Java 线程的状态

  - New：初始状态，线程被构建，没有调用 start 方法
  - RUNABLE：运行状态，Java 将就绪、运行状态的线程统称“运行中”
  - BLOCKED：阻塞，阻塞于锁
  - WATING：等待，当前线程需要等待其他线程
  - TIME_WAITING：超时等待，可以在指定时间内返回
  - TERMINATED：终止状态，线程执行完成

- sleep() 方法和 wait()

  - sleep 方法用于暂停执行，没有释放锁；wait 方法用于线程间交互/通信，释放锁
  - sleep 之后线程自动苏醒；wait 之后，需要等待 notify、notifyAll

- 进程与线程的区别，进程间通信，线程间通信

  - 进程：是系统运行程序的基本单位
  - 线程：操作系统能够进行运算调度的最小单位，多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈
  - 进程间通信

    - 管道/匿名管道

      - 实质：
        - 内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据
        - 一个数据只能被读一次，读出来以后在缓冲区就不复存在了
        - 当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列
      - 限制：
        - 支持单向数据流
        - 只能用于具有亲缘关系的进程之间
        - 缓冲区是有限的
        - 无格式字节流

    - 有名管道

      - 一个路径名与之关联，以有名管道的文件形式存在于文件系统中
      - 只要可以访问该路径，就能够彼此通过有名管道相互通信

    - 信号

      - 信号可以在任何时候发给某一进程，而无需知道该进程的状态
      - 如果该进程当前并未处于执行状态，则该信号就有内核保存起来，直到该进程回复执行并传递给它为止
      - 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程

    - 消息队列

      - 存放在内核中的消息链表，每个消息队列由消息队列标识符表示
      - 消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除
      - 允许一个或多个进程向它写入与读取消息.

    - 共享内存

      - 多个进程可以可以直接读写同一块内存空间
      - 多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥

    - 信号量
      - 意图在于进程间同步
    - socket

  - 线程间通信
    - wait/notify
    - join
    - violate 共享内存
      - 防止 JVM 的指令重排
      - 保证变量在多个线程之间的可见性
    - CountDownLatch
    - 锁机制
    - 管道通信
      - PipedWriter/PipedReader

- Java 线程池

  - Runnable/Callable

    - Runnable: 不会返回结果或抛出检查异常
    - Callable: 可以返回结果或抛出检查异常

  - execute/submit

    - execute：提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否
    - submit：提交需要返回值的任务，线程池会返回一个 Future 类型的对象

  - ThreadPoolExecutor
    - 参数
      - corePoolSize： 最小可以同时运行的线程数量
      - maximumPoolSize： 最大线程数
      - workQueue：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中
      - keepAliveTime： 当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程等待的时间超过了 keepAliveTime 才会被回收销毁
      - unit：keepAliveTime 时间单位
      - threadFactory：创建新线程的时候会用到
      - handler：饱和策略
        - 抛出 RejectedExecutionException 来拒绝新任务的处理
        - 处理新任务，直接丢弃掉
        - 丢弃最早的未处理的任务请求
        - 直接在 execute 方法的调用线程中运行被拒绝的任务

- 原子类（Atomic）

  - 主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作

- 锁

  - 悲观锁：每次在拿数据的时候都会上锁
  - 乐观锁：在更新的时候会判断一下在此期间别人有没有去更新这个数据
    - 实现：
      - 版本号机制
      - CAS
    - 缺点
      - ABA
        - compareAndSet：先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值
      - 自旋 CAS 带来 CPU 开销
  - 自旋锁：如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环
    - 优点
      - 线程的状态不会改变，不会使线程进入阻塞状态
    - 缺点
      - 循环等待，消耗 CPU
      - 无法满足等待时间最长的线程优先获取锁
      - 也无法保证可重入性

- List、Set、Map

  - List(对付顺序的好帮手)： 存储的元素是有序的、可重复的
  - Set(注重独一无二的性质): 存储的元素是无序的、不可重复的
  - Map(用 Key 来搜索的专家): 使用键值对（kye-value）存储

- HashMap、HashTable、ConcurrentHashMap

  - HashMap：数组+链表/红黑树
  - HashTable：数组+链表；线程安全
  - ConcurrentHashMap：线程安全
  - 首先获得对应的 Segment 的锁； Segment 数组 + HashEntry 数组 + 链表
  - 只锁定当前链表或红黑二叉树的首节点； Node 数组 + 链表 / 红黑树

- ArrayList、LinkedList；ArrayList 扩容

  - Arraylist 基于数组， LinkedList 基于双向链表
  - 都是不保证线程安全
  - ArrayList 扩容
    - 新容量更新为 max(最小需要容量, 旧容量的 1.5 倍)
    - 新容量大于 MAX_ARRAY_SIZE（Integer.MAX_VALUE - 8）
      - 如果最小需要容量大于 MAX_ARRAY_SIZE，新容量为 Integer.MAX_VALUE
      - 否则，新容量为 Integer.MAX_ARRAY_SIZE
    - 元素 copy
      - System.arraycopy()，支持从制定位置开始的复制
      - Arrays.copyOf()，支持指定复制长度
    - 在 add 大量元素之前用 ensureCapacity 方法，以减少增量重新分配的次数

- CopyOnWriteArrayList

  - 写时复制操作，写操作加锁
    - 获取 ReentrantLock 锁
    - 复制数组
    - 添加元素到新的数组
    - 使用新的数组，将原数组进行替换
    - 解锁
  - 读数据
    - 直接读，不需要加锁

- Cookie 与 Session

  - cookie
    - 为了辨别用户身份，暂存在用户本地的信息
  - Session
    - 服务端记录客户端访问状态的机制

- Java 序列化

  - 将对象写入到 IO 流中
  - 如果想让某个变量不被序列化，使用 transient 修饰
  - 序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错
  - 同一对象序列化多次，只有第一次序列化为二进制流，以后都只是保存序列化编号，不会重复序列化。
  - 建议所有可序列化的类加上 serialVersionUID 版本号，方便项目升级

- equals 方法实现
- static、final、volatile、synchronized

  - synchronized
    - 作用：解决的是多个线程之间访问资源的同步性，被它修饰的方法或者代码块在任意时刻只能有一个线程执行
    - 使用方式
      - 修饰方法：作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁
      - 修饰静态方法：作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁
      - 修饰代码块：对给定对象/类加锁

- 深拷贝、浅拷贝

  - 浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝
  - 深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝

- IO、NIO、BIO、AIO

  - 抽象类
    InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
    OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

  - IO
    - 按照流的流向分，可以分为输入流和输出流；
    - 按照操作单元划分，可以划分为字节流和字符流；
    - 按照流的角色划分为节点流和处理流。

## JVM

- JVM 加载字节码文件
- JVM 内存模型
- JVM 运行时数据区
- GCROOT
- JVM GC 及算法
- 什么情况出现 Full GC、Yong GC
- 内存溢出

## 技术深度

- HTTP 协议
- TCP 协议
- 一致性 Hash
- HTTP 连接池
- 数据库连接池

## 技术框架

- Netty
- Spring IOC
- Spring AOP
- Zookeeper
- rabbitMQ

## 系统架构

- 哪些设计模式能增加系统的可扩展性
- 设计模式
- 什么是高内聚低耦合
- 什么情况用接口，什么情况用消息
- AB 两个系统相互依赖，如何解耦
- 如何写一篇技术文档
- 拆分系统与合并系统

## 分布式系统

- 分布式事务
- 分布式锁
- 分布式 Session
- 消息一致性
- 负载均衡
- 正向代理与反向代理
- CDN
- DNS
