# Java

## 基础题目

- Java 线程的状态

  - New：初始状态，线程被构建，没有调用 start 方法
  - RUNABLE：运行状态，Java 将就绪、运行状态的线程统称“运行中”
  - BLOCKED：阻塞，阻塞于锁
  - WATING：等待，当前线程需要等待其他线程
  - TIME_WAITING：超时等待，可以在指定时间内返回
  - TERMINATED：终止状态，线程执行完成

- sleep() 方法和 wait()

  - sleep 方法用于暂停执行，没有释放锁；wait 方法用于线程间交互/通信，释放锁
  - sleep 之后线程自动苏醒；wait 之后，需要等待 notify、notifyAll

- 进程与线程的区别，进程间通信，线程间通信

  - 进程：是系统运行程序的基本单位
  - 线程：操作系统能够进行运算调度的最小单位，多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈
  - 进程间通信

    - 管道/匿名管道

      - 实质：
        - 内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据
        - 一个数据只能被读一次，读出来以后在缓冲区就不复存在了
        - 当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列
      - 限制：
        - 支持单向数据流
        - 只能用于具有亲缘关系的进程之间
        - 缓冲区是有限的
        - 无格式字节流

    - 有名管道

      - 一个路径名与之关联，以有名管道的文件形式存在于文件系统中
      - 只要可以访问该路径，就能够彼此通过有名管道相互通信

    - 信号

      - 信号可以在任何时候发给某一进程，而无需知道该进程的状态
      - 如果该进程当前并未处于执行状态，则该信号就有内核保存起来，直到该进程回复执行并传递给它为止
      - 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程

    - 消息队列

      - 存放在内核中的消息链表，每个消息队列由消息队列标识符表示
      - 消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除
      - 允许一个或多个进程向它写入与读取消息.

    - 共享内存

      - 多个进程可以可以直接读写同一块内存空间
      - 多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥

    - 信号量
      - 意图在于进程间同步
    - socket

  - 线程间通信
    - wait/notify
    - join
    - violate 共享内存
      - 防止 JVM 的指令重排
      - 保证变量在多个线程之间的可见性
    - CountDownLatch
    - 锁机制
    - 管道通信
      - PipedWriter/PipedReader

- Java 线程池

  - Runnable/Callable

    - Runnable: 不会返回结果或抛出检查异常
    - Callable: 可以返回结果或抛出检查异常

  - execute/submit

    - execute：提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否
    - submit：提交需要返回值的任务，线程池会返回一个 Future 类型的对象；提交任务调用的是 execute

  - 通过 Executor 框架的工具类 Executors 创建

    - FixedThreadPool
      - 返回一个固定线程数量的线程池，当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务
    - SingleThreadExecutor
      - 返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务
    - CachedThreadPool
      - 返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用

  - 通过 ThreadPoolExecutor 创建

    - 参数
      - corePoolSize： 最小可以同时运行的线程数量
      - maximumPoolSize： 最大线程数
      - workQueue：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中
      - keepAliveTime：当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程等待的时间超过了 keepAliveTime 才会被回收销毁
      - unit：keepAliveTime 时间单位
      - threadFactory：创建新线程的时候会用到
      - handler：饱和策略
        - 抛出 RejectedExecutionException 来拒绝新任务的处理
        - 处理新任务，直接丢弃掉
        - 丢弃最早的未处理的任务请求
        - 直接在 execute 方法的调用线程中运行被拒绝的任务
    - 任务调度
      - 首先检测线程池运行状态，如果不是 RUNNING，则直接拒绝，线程池要保证在 RUNNING 的状态下执行任务
      - 如果 workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务
      - 如果 workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中
      - 如果 workerCount >= corePoolSize && workerCount < maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务
      - 如果 workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常
    - 任务缓冲
      - 阻塞队列
        - ArrayBlockingQueue 有界队列：基于数组、ReentrantLock
        - LinkedBlockingQueue 有界队列：基于链表、ReentrantLock
        - SynchronousQueue 阻塞队列：写满队列、读空队列阻塞
    - 任务申请

      - 任务的执行
        - 直接由新创建的线程执行
        - 线程从任务队列中获取任务然后执行（ThreadPoolExecutor.getTask），执行完任务的空闲线程会再次去从队列中申请任务再去执行
          - 线程池已停止，返回 null
          - 检查 worker 线程是否过多，是，则返回 null
          - 检查线程是否可回收，是，则限时获取任务；否，阻塞获取任务（核心线程可以无限等待获取任务，非核心线程要限时获取任务）

    - Worker 线程管理
      - Worker 线程
        - ThreadPoolExecutor 使用 HashSet 保存 Worker 的引用
        - 实现了 Runnable 接口
        - 并持有一个线程 thread：在调用构造方法时通过 ThreadFactory 来创建的线程
        - 一个初始化的任务 firstTask：保存传入的第一个任务
        - Worker 通过继承 AQS 来实现独占锁这个功能，目的是实现不可重入的特性去反应线程现在的执行状态
          - 1.lock 方法一旦获取了独占锁，表示当前线程正在执行任务中
          - 2.如果正在执行任务，则不应该中断线程
          - 3.如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断
          - 4.线程池在执行 shutdown 方法或 tryTerminate 方法时会调用 interruptIdleWorkers 方法来中断空闲的线程，interruptIdleWorkers 方法会使用 tryLock 方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。
      - Worker 线程增加
        - 通过 addWorker 方法
      - Worker 线程回收
        - 获取不到任务时，主动回收自己(processWorkerExit)
          - 将 Worker 移除 HashSet
          - 但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程

- Java 线程模型

  - 1:1 内核线程模型

    - 完全依赖操作系统内核线程来完成多线程并发
    - 线程的调度通过内核来完成
    - 一般情况下应用程序不会直接调用内核线程， 而是采用内核线程向上提供的接口 轻量级进程。我们可以抽象的把轻量级进程理解为线程，每个轻量级进程都会有一个内核线程与之一一对应
    - 缺陷
      - 线程的创建、同步等操作都需要采用系统调用，而系统调用本身代价比较大，需要线程在用户态和内核态之间不断切换
      - 线程的创建需要耗费一定的内核资源，而内核资源本身较少，线程数有限

  - 1:N 用户线程模型

    - 进程与用户线程为 1:N 的关系
    - 指完全建立在用户态的线程，它的创建、启动、阻塞，停止等操作可以在用户态独立完成，不需要内核线程的帮助
    - 需要自己维护

  - N：M 用户线程与轻量级进程混合模型
    - 轻量级进程作为用户线程和内核线程的桥梁，可以使用内核提供的线程调度功能及处理器映射，此时用户线程的系统调用通过内核线程来完成
    - 一个 轻量级进程 可以对接多个 用户进程，而每个 用户进程 又包含多个 轻量级进程

- 原子类（Atomic）

  - 具有原子操作特征的类
  - 类型

    - 原子更新基本类型
    - 原子更新数组
    - 原子更新引用
    - 原子更新属性

  - 主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作

- CAS

  - CAS 操作数
    - 内存值 V
    - 旧的预期值 A
    - 要修改的新值 B
  - 如果内存值 V 和我们的预期值 A 相等，则将内存值修改为 B，操作成功！
  - 如果内存值 V 和我们的预期值 A 不相等，一般也有两种情况：

    - 重试(自旋)
      - 计算内存地址 V、预期值 A 和更新值 B
      - 比较 V 和 A，相等则将变量更新为 B，否则进行自选，重新走一遍这两个步骤
    - 什么都不做，ZAS 失败

  - ABA 问题：待修改变量可能经过多次更新，但最终与预期值一致，但线程无法感知修改过程
    - 解决 ABA 问题：使用 JDK 给我们提供的 AtomicStampedReference 和 AtomicMarkableReference 类
      - AtomicStampedReference
        - 为这个对象提供了一个 stamp 版本，并且这个版本如果被修改了，是自动更新的
      - AtomicMarkableReference
        - 为这个对象提供了 mark 标志，并且这个标志如果被修改了，是自动更新的
  - 执行开销
    - CAS 机制如果 expect 和 V 长时间都不一致，会进行自旋操作（即不断的重试），这会给 CPU 带来非常大的执行开销
    - CAS 机制只能保证一个临界变量的原子操作 ，当操作涉及多个共享变量时 CAS 无效

- synchronized

  - JVM 中对象布局分为三块区域

    - 区域划分
      - 对象头：Mark Word、Klass Pointer
      - 实例数据
      - 对齐填充
    - 当线程访问同步块时首先需要获得锁并把相关信息存储在对象头中

  - 锁状态升级流程

    - 偏向锁

      - 获取锁时处理流程
        - 检查 mark word 的线程 id
        - 如果为空则设置 CAS 替换当前线程 id；如果替换成功则获取锁成功，如果失败则撤销偏向锁
        - 如果不为空则检查 线程 id 为是否为本线程。如果是则获取锁成功，如果失败则撤销偏向锁
      - 偏向锁的撤销
        - 偏向锁的撤销动作必须等待全局安全点
        - 暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态
        - 撤销偏向锁恢复到无锁（标志位为 01）或轻量级锁（标志位为 00）的状态
      - 优点
        - 只有一个线程执行同步块时进一步提高性能，适用于一个线程反复获得同一锁的情况。偏向锁可以提高带有同步但无竞争的程序性能。
      - 缺点
        - 如果存在竞争会带来额外的锁撤销操作

    - 轻量级锁

      - 加锁：多个线程竞争偏向锁导致偏向锁升级为轻量级锁
        - JVM 在当前线程的栈帧中创建 Lock Reocrd，并将对象头中的 Mark Word 复制到 Lock Reocrd 中
        - 线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向 Lock Reocrd 的指针。
        - 如果成功则获得锁，如果失败则先检查对象的 Mark Word 是否指向当前线程的栈帧如果是则说明已经获取锁，否则说明其它线程竞争锁则膨胀为重量级锁
      - 解锁
        - 使用 CAS 操作将 Mark Word 还原， 成功则解锁成功，否则膨胀为重量级锁
      - 优点
        - 其性能提升的依据是对于绝大部分的锁在整个生命周期内都是不会存在竞争。在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。
      - 缺点

        - 在有多线程竞争的情况下轻量级锁增加了额外开销

      - 自旋锁

        - 在膨胀为重量级锁的过程中或重入时会多次尝试自旋获取锁以避免线程唤醒的开销，但是它会占用 CPU
        - 适应性自旋锁
          - 自旋的次数不在固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定
        - 优点
          - 竞争的线程不会阻塞挂起，提高了程序响应速度。避免重量级锁引起的性能消耗
        - 缺点
          - 如果线程始终无法获取锁，自旋消耗 CPU 最终会膨胀为重量级锁。

    - 重量级锁
      - 在重量级锁中没有竞争到锁的对象会 park 被挂起，退出同步块时 unpark 唤醒后续线程
      - ObjectMonitor 中包含一个同步队列和一个等待队列

- 锁

  - 悲观锁：每次在拿数据的时候都会上锁
  - 乐观锁：在更新的时候会判断一下在此期间别人有没有去更新这个数据
    - 实现：
      - 版本号机制
      - CAS

- AQS

  - 用来构建锁和同步器的框架
  - 原理概览
    - 如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态
    - 如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中
      - CLH 队列是一个双向链表，AQS 是将每条请求共享资源的线程封装成一个 CLH 的一个结点（Node）来实现锁的分配
      - 使用一个 int 成员变量来表示同步状态，使用 volatile 修饰保证线程可见性；使用 CAS 对该同步状态进行原子操作实现对其值的修改
  - 对资源的共享方式
    - Exclusive（独占）：只有一个线程能执行，如 ReentrantLock(state 初始化为 0, state+1/-1)
      - 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁
      - 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的
    - Share（共享）：多个线程可同时执行，如 CountDownLatch（state 也初始化为 N， countDown 时 state-1）；Semaphore 信号量（state 为一组 许可（permit），操作时首先要获取到许可，才能进行操作，操作完成后需要释放许可。如果没有获取许可，则阻塞到有许可被释放）
  - 自定义同步器一般的方式
    - 使用者继承 AbstractQueuedSynchronizer 并重写指定的方法
      - isHeldExclusively()//该线程是否正在独占资源。只有用到 condition 才需要去实现它。
      - tryAcquire(int)//独占方式。尝试获取资源，成功则返回 true，失败则返回 false。
      - tryRelease(int)//独占方式。尝试释放资源，成功则返回 true，失败则返回 false。
      - tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
      - tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回 true，失败则返回 false。
    - 将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法
  - 数据结构
    - 同步队列
      - 双向链表，将每条请求共享资源的线程封装成节点
      - 每一个结点都是由前一个结点唤醒
    - Condition queue
      - 不是必须的其是一个单向链表，只有当使用 Condition 时，才会存在此单向链表，可能存在多条

- volatile、synchronized

  - synchronized

    - 作用：解决的是多个线程之间访问资源的同步性，被它修饰的方法或者代码块在任意时刻只能有一个线程执行
    - 使用方式
      - 修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁
      - 修饰静态方法：给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁
      - 修饰代码块：指定加锁对象，对给定对象/类加锁

  - volatile

    - 防止 JVM 的指令重排
    - 保证变量的可见性
      - 指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取

  - synchronized 关键字和 volatile 关键字的区别
    - volatile 关键字是线程同步的轻量级实现，所以 volatile 性能肯定比 synchronized 关键字要好。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块。
    - volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。
    - volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。

- synchronized 和 ReentrantLock 的区别

  - 两者都是可重入锁
    - “可重入锁” 指的是自己可以再次获取自己的内部锁
    - 同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁
  - synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API
    - synchronized 是依赖于 JVM 实现的
    - ReentrantLock 是 JDK 层面实现的
  - ReentrantLock 比 synchronized 增加了一些高级功能
    - 等待可中断
      - ReentrantLock 提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情
    - 可实现公平锁
      - ReentrantLock 可以指定是公平锁还是非公平锁。而 synchronized 只能是非公平锁
    - 可实现选择性通知（锁可以绑定多个条件）
      - synchronized 关键字与 wait()和 notify()/notifyAll()方法相结合可以实现等待/通知机制。
      - ReentrantLock 类当然也可以实现，但是需要借助于 Condition 接口与 newCondition()方法

- List、Set、Map

  - List(对付顺序的好帮手)： 存储的元素是有序的、可重复的
  - Set(注重独一无二的性质): 存储的元素是无序的、不可重复的
  - Map(用 Key 来搜索的专家): 使用键值对（kye-value）存储

- HashMap、HashTable、ConcurrentHashMap

  - HashMap：数组+链表/红黑树
  - HashTable：数组+链表；线程安全
  - ConcurrentHashMap：线程安全
    - 首先获得对应的 Segment 的锁； Segment 数组 + HashEntry 数组 + 链表
    - 只锁定当前链表或红黑二叉树的首节点； Node 数组 + 链表 / 红黑树

- ArrayList、LinkedList；ArrayList 扩容

  - Arraylist 基于数组， LinkedList 基于双向链表
  - 都是不保证线程安全
  - ArrayList 扩容
    - 新容量更新为 max(最小需要容量, 旧容量的 1.5 倍)
    - 新容量大于 MAX_ARRAY_SIZE（Integer.MAX_VALUE - 8）
      - 如果最小需要容量大于 MAX_ARRAY_SIZE，新容量为 Integer.MAX_VALUE
      - 否则，新容量为 Integer.MAX_ARRAY_SIZE
    - 元素 copy
      - System.arraycopy()，支持从制定位置开始的复制
      - Arrays.copyOf()，支持指定复制长度
    - 在 add 大量元素之前用 ensureCapacity 方法，以减少增量重新分配的次数

- CopyOnWriteArrayList

  - 写时复制操作，写操作加锁
    - 获取 ReentrantLock 锁
    - 复制数组
    - 添加元素到新的数组
    - 使用新的数组，将原数组进行替换
    - 解锁
  - 读数据
    - 直接读，不需要加锁

- Cookie 与 Session

  - cookie
    - 为了辨别用户身份，暂存在用户本地的信息
  - Session
    - 服务端记录客户端访问状态的机制

- Java 序列化

  - 将对象写入到 IO 流中
  - 如果想让某个变量不被序列化，使用 transient 修饰
  - 序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错
  - 同一对象序列化多次，只有第一次序列化为二进制流，以后都只是保存序列化编号，不会重复序列化。
  - 建议所有可序列化的类加上 serialVersionUID 版本号，方便项目升级

- equals 方法实现

  - “==”比较两个对象的的内存地址
  - equals() 方法是进行内容比较

- static、final、this、super

  - final

    - final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；
    - final 修饰的方法不能被重写；
    - final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象
    - 类中所有的 private 方法都隐式地指定为 final

  - static

    - 修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享; 静态变量 存放在 Java 内存区域的方法区
    - 静态代码块: 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次
    - 静态内部类
      - 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外部类，但是静态内部类却没有
      - 它的创建是不需要依赖外部类的创建；它不能使用任何外部类的非 static 成员变量和方法
      - 静态导包：指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法

  - this

    - 引用类的当前实例

  - super
    - 从子类访问父类的变量和方法
    - 在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。
    - this、super 不能用在 static 方法中

- try-with-resources

  - 适用范围（资源的定义）： 任何实现 java.lang.AutoCloseable 或者``java.io.Closeable` 的对象
  - 关闭资源和 final 的执行顺序： 在 try-with-resources 语句中，任何 catch 或 finally 块在声明的资源关闭后运行

- ThreadLocal

  - ThreadLocal 类主要解决的就是让每个线程绑定自己的值
  - 每个 Thread 中都具备一个 ThreadLocalMap，而 ThreadLocalMap 可以存储以 ThreadLocal 为 key ，Object 对象为 value 的键值对
  - 最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是 ThreadLocalMap 的封装，传递了变量值
  - ThreadLocalMap
    - hash 冲突
      - 遇到了 key 值相等的数据，直接更新即可；
      - 遇到 key 为 null 的 Entry，直接替换更新；
      - 如果找到 Entry 为 null 的槽位，则将数据放入该槽位中
    - 过期 key 的探测式清理流程
      - 探测式清理
        - 遍历散列数组，从开始位置向后探测清理过期数据，将过期数据的 Entry 设置为 null
        - 碰到未过期的数据则将此数据 rehash 后重新在 table 数组中定位，如果定位的位置已经有了数据，则会将未过期的数据放到最靠近此位置的 Entry=null 的桶中
      - 启发式清理
        - 探测式清理是以当前 Entry 往后清理，遇到值为 null 则结束清理，属于线性探测清理
        - 从制定位置，遍历指定数量的 Extry，遇到过期 Entry，执行过期清理
  - InheritableThreadLocal：父子线程共享
    - InheritableThreadLocal 是在 new Thread 中的 init()方法给赋值的
  - 场景
    - requestId 传递

- 深拷贝、浅拷贝

  - 浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝
  - 深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝

- IO、NIO、BIO、AIO

  - 抽象类
    InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
    OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

  - IO

    - 按照流的流向分，可以分为输入流和输出流；
    - 按照操作单元划分，可以划分为字节流和字符流；
    - 按照流的角色划分为节点流和处理流。

  - BIO(Blocking I/O)

    - 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成

  - NIO (Non-blocking/New I/O)

    - 特性
      - IO 流是阻塞的，NIO 是非阻塞的
        - NIO 允许我们进行非阻塞 IO 操作；比如说，单线程中从通道读取数据到 buffer，同时可以继续做别的事情，当数据读取到 buffer 中后，线程再继续处理数据。写数据也是一样的；
      - Buffer：IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)
        - 在 NIO 厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中
        - 在面向流的 I/O 中·可以将数据直接写入或者将数据直接读到 Stream 对象中
      - Channel（通道）
        - NIO 通过 Channel（通道） 进行读写；通道只能和 Buffer 交互
      - Selector (选择器)
        - 选择器用于使用单个线程处理多个通道
    - 核心组件
      - Buffers
        - 用于和 Channel 交互
        - 内存区缓存，属性：capacity 容量、position 位置、limit 限制
      - Channels 通道
        - FileChannel
        - SocketChannel 和 ServerSocketChannel
        - DatagramChannel
        - Scatter 和 Gather
        - 通道之间的数据传输
      - Selectors
        - 检查一个或多个 NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个 channels

  - AIO (Asynchronous I/O)
    - 异步非阻塞的 IO 模型
    - 基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作

## JVM

- JVM 加载字节码文件

  - 类加载过程
    - 加载
      - 通过全类名获取定义此类的二进制字节流
      - 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
      - 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口
    - 连接
      - 验证
        - 文件格式验证：验证字节码是否符合 Class 文件格式规范，如版本号，常量类型
        - 元数据验证：对字节码进行语义分析，如类是否有父类，是否继承了不允许继承的类
        - 字节码验证：通过数据流和控制流分析，确认程序语义合法、符合逻辑
        - 符号引用验证：确保解析缓解能正确执行
      - 准备
        - 为 static 类变量分配内存并设置类变量初始值的阶段
      - 解析
        - 将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行
    - 初始化
      - 执行类构造器 clinit ()方法的过程
        - new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时
        - 对类进行反射调用时，如果类没初始化，需要触发其初始化
        - 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化
    - 卸载
      - 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。
      - 该类没有在其他任何地方被引用
      - 该类的类加载器的实例已被 GC

- 类加载器

  - BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由 C++实现，负责加载 %JAVA_HOME%/lib 目录下的 jar 包和类或者或被 -Xbootclasspath 参数指定的路径中的所有类
  - ExtensionClassLoader(扩展类加载器) ：主要负责加载目录 %JRE_HOME%/lib/ext 目录下的 jar 包和类，或被 java.ext.dirs 系统变量所指定的路径下的 jar 包
  - AppClassLoader(应用程序类加载器) :面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类
  - 自定义类加载器：除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自 java.lang.ClassLoader。如果我们要自定义自己的类加载器，很明显需要继承 ClassLoader

  - 双亲委派模型

    - 加载的时候，首先会把该请求委派该父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理
    - 当父类加载器为 null 时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器

- JVM 内存模型

  - 线程私有
    - 程序计数器：用于读取指令
    - 虚拟机栈：Java 方法执行的内存模型
    - 本地方法栈
      - Native 方法执行的内存模型
      - 本地方法一般是用其它语言(C、C++ 或汇编语言等)编写的，并且被编译为基于本机硬件和操作系统的程序
  - 线程共享
    - 堆：存放对象实例，几乎所有的对象实例以及数组都在这里分配内存
      - 细分：
        - 新生代
          - Eden
          - From
          - To
        - 老年代
        - Eden -> s0 -> s1 -> 老年代
    - 方法区
      - 用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
      - 运行时常量池
    - 直接内存
      - 使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作
      - 避免了在 Java 堆和 Native 堆中来回复制数据

- 对象的创建

  - 类加载检查
    - 在常量池中定位到这个类的符号引用， 如果没有，那必须先执行相应的类加载过程
    - 分配内存
      - 分配方式
        - 指针碰撞：标记-压缩算法下，没有内存碎片，根据要分配的大小，移动未使用内存的指针
        - 空闲列表：标记-清除算法下，有内存碎片，在空闲列表中找到大小符合的内存快分配
      - 并发问题
        - CAS+重试
        - TLAB：为每一个线程预先在 Eden 区分配一块儿内存，优先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配
    - 初始化零值
    - 设置对象头
    - 执行 init

- 判断一个对象是否可被回收

  - 引用计数
  - 可达性分析
    - 当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的
    - GC Roots
      - 虚拟机栈中引用的对象
      - 本地方法栈中引用的对象
      - 方法区中类静态属性引用的对象
      - 方法区中的常量引用的对象
  - 方法区的回收
    - 方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高
    - 主要是对常量池的回收和对类的卸载
      - 该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例
      - 加载该类的 ClassLoader 已经被回收
      - 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。
  - finalize
    - 当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救
    - 自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法

- 引用

  - 无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关
  - 强引用
    - 被强引用关联的对象不会被回收
    - 使用 new 一个新对象的方式来创建强引用
  - 软引用
    - 被软引用关联的对象只有在内存不够的情况下才会被回收
    - 使用 SoftReference 类来创建软引用
  - 弱引用
    - 被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前
    - 使用 WeakReference 类来实现弱引用
  - 虚引用
    - 一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象
    - 为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知
    - 使用 PhantomReference 来实现虚引用

- 垃圾回收算法

  - 标记-清除
    - 将存活的对象进行标记，然后清理掉未被标记的对象
    - 标记和清除过程效率都不高，会产生内存碎片
  - 复制
    - 将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉
  - 标记-整理算法
    - 标记之后，让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存
    - 现在的商业虚拟机都采用这种收集算法来回收新生代
      - 但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor
      - 在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor
  - 分代收集算法
    - 根据各个年代的特点选择合适的垃圾收集算法
    - 新生代：复制算法；每次收集都会有大量对象死去，只需要付出少量对象的复制成本就可以完成每次垃圾收集
    - 老年代：标记-清除/标记-整理；对象存活几率是比较高的，而且没有额外的空间对它进行分配担保

- 垃圾回收器

  - Serial 收集器
    - 只会使用一条垃圾收集线程去完成垃圾收集工作，在进行垃圾收集工作的时候必须暂停其他所有的工作线程
    - 新生代采用复制算法，老年代采用标记-整理算法
  - ParNew 收集器
    - 使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样
    - 新生代采用复制算法，老年代采用标记-整理算法
    - 能与 CMS 收集器配合
  - Parallel Scavenge 收集器
    - 关注点是吞吐量（高效率的利用 CPU）
    - 新生代采用复制算法，老年代采用标记-整理算法
  - Serial Old 收集器
    - Serial 收集器的老年代版本，它同样是一个单线程收集器
    - 作为 CMS 收集器的后备方案
  - Parallel Old 收集器
    - Parallel Scavenge 收集器的老年代版本
    - 使用多线程和“标记-整理”算法
  - CMS
    - 关注点更多的是用户线程的停顿时间（提高用户体验），垃圾收集线程与用户线程同时工作
    - 标记-清除
      - 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿
      - 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿
      - 重新标记：了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿
      - 并发清除：开启用户线程，同时 GC 线程开始对未标记的区域做清扫
  - G1
    - G1 可以直接对新生代和老年代一起回收
    - G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离，每个小空间可以单独进行垃圾回收
    - 记录每个 Region 垃圾回收时间以及回收所获得的空间，维护了一个优先列表，优先选择回收价值最大的 Region
    - 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描
    - 过程
      - 初始标记
      - 并发标记
      - 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行
      - 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率
    - 特点
      - 空间整合: 整体来看是基于“标记 - 整理”算法实现的收集器，从局部(两个 Region 之间)上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片
      - 可预测的停顿: 能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒

- 什么情况出现 Full GC、Young GC

  - young GC

    - Eden 区的空间耗尽了

  - Full GC

    - 发生 Young GC 之前进行检查， 可能升入老年代的对象大小，可能超过了老年代当前可用内存空间
    - 执行 Young GC 之后有一批对象需要放入老年代，此时老年代就是没有足够的内存空间存放这些对象
    - 老年代内存使用率超过了一定比率，也要直接触发 Old GC
    - System.gc()，heap dump 带 GC,其默认都是触发 full GC

## Spring IOC && AOP

### IOC

- 控制领域对象的创建以及管理
- 例如：现有类 A 依赖于类 B
  - 传统的开发方式 ：往往是在类 A 中手动通过 new 关键字来 new 一个 B 的对象出来
  - 使用 IoC 思想的开发方式 ：不通过 new 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面过去即可
- 优点
  - 对象之间的耦合度或者说依赖程度降低
  - 资源变的容易管理；比如你用 Spring 容器提供的话很容易就可以实现一个单例

### AOP

- 面向切面编程，AOP 是 OOP（面向对象编程）的一种延续
- 在不改变原有业务逻辑的情况下，增强横切逻辑代码，根本上解耦合，避免横切逻辑代码重复

## 系统架构

- 代理模式

  - 静态代理
    - 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件
    - 静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改
    - 步骤
      - 定义一个接口及其实现类；
      - 创建一个代理类同样实现这个接口
      - 将目标对象注注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。
  - 动态代理

    - 在运行时动态生成类字节码，并加载到 JVM 中的
    - JDK 动态代理机制

      - 只能代理实现了接口的类

      - 定义一个接口及其实现类；
      - 自定义 InvocationHandler 并重写 invoke 方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；
      - 通过 Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h) 方法创建代理对象；

    - CGLIB

      - CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法

      - 定义一个类；
      - 自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似；
      - 通过 Enhancer 类的 create()创建代理类；

- 哪些设计模式能增加系统的可扩展性
  - 工厂模式
  - 代理模式
  - 适配器模式
- 设计模式
- 什么是高内聚低耦合
- 什么情况用接口，什么情况用消息
- AB 两个系统相互依赖，如何解耦
- 如何写一篇技术文档
- 拆分系统与合并系统

## 分布式系统

- 分布式事务
- 分布式锁
- 分布式 Session
- 消息一致性
- 负载均衡
- 正向代理与反向代理
- CDN
- DNS
