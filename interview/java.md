# Java

## 基础题目

- Java 线程的状态

  - New：初始状态，线程被构建，没有调用 start 方法
  - RUNABLE：运行状态，Java 将就绪、运行状态的线程统称“运行中”
  - BLOCKED：阻塞，阻塞于锁
  - WATING：等待，当前线程需要等待其他线程
  - TIME_WAITING：超时等待，可以在指定时间内返回
  - TERMINATED：终止状态，线程执行完成

- sleep() 方法和 wait()

  - sleep 方法用于暂停执行，没有释放锁；wait 方法用于线程间交互/通信，释放锁
  - sleep 之后线程自动苏醒；wait 之后，需要等待 notify、notifyAll

- 进程与线程的区别，进程间通信，线程间通信

  - 进程：是系统运行程序的基本单位
  - 线程：操作系统能够进行运算调度的最小单位，多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈
  - 进程间通信

    - 管道/匿名管道

      - 实质：
        - 内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据
        - 一个数据只能被读一次，读出来以后在缓冲区就不复存在了
        - 当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列
      - 限制：
        - 支持单向数据流
        - 只能用于具有亲缘关系的进程之间
        - 缓冲区是有限的
        - 无格式字节流

    - 有名管道

      - 一个路径名与之关联，以有名管道的文件形式存在于文件系统中
      - 只要可以访问该路径，就能够彼此通过有名管道相互通信

    - 信号

      - 信号可以在任何时候发给某一进程，而无需知道该进程的状态
      - 如果该进程当前并未处于执行状态，则该信号就有内核保存起来，直到该进程回复执行并传递给它为止
      - 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程

    - 消息队列

      - 存放在内核中的消息链表，每个消息队列由消息队列标识符表示
      - 消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除
      - 允许一个或多个进程向它写入与读取消息.

    - 共享内存

      - 多个进程可以可以直接读写同一块内存空间
      - 多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥

    - 信号量
      - 意图在于进程间同步
    - socket

  - 线程间通信
    - wait/notify
    - join
    - violate 共享内存
      - 防止 JVM 的指令重排
      - 保证变量在多个线程之间的可见性
    - CountDownLatch
    - 锁机制
    - 管道通信
      - PipedWriter/PipedReader

- Java 线程池

  - Runnable/Callable

    - Runnable: 不会返回结果或抛出检查异常
    - Callable: 可以返回结果或抛出检查异常

  - execute/submit

    - execute：提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否
    - submit：提交需要返回值的任务，线程池会返回一个 Future 类型的对象

  - 通过 Executor 框架的工具类 Executors 创建

    - FixedThreadPool
      - 返回一个固定线程数量的线程池，当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务
    - SingleThreadExecutor
      - 返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务
    - CachedThreadPool
      - 返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用

  - 通过 ThreadPoolExecutor 创建
    - 参数
      - corePoolSize： 最小可以同时运行的线程数量
      - maximumPoolSize： 最大线程数
      - workQueue：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中
      - keepAliveTime：当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程等待的时间超过了 keepAliveTime 才会被回收销毁
      - unit：keepAliveTime 时间单位
      - threadFactory：创建新线程的时候会用到
      - handler：饱和策略
        - 抛出 RejectedExecutionException 来拒绝新任务的处理
        - 处理新任务，直接丢弃掉
        - 丢弃最早的未处理的任务请求
        - 直接在 execute 方法的调用线程中运行被拒绝的任务
    - 过程
      - 提交任务
      - 核心线程数未满，创建线程执行任务
      - 检查 runState，加入队列
        - 重新检查 runState，异常则移除任务
        - 线程数未满，创建线程并执行任务
      - 队列已满，执行 reject

- Java线程模型

  - 1:1 内核线程模型
    - 完全依赖操作系统内核线程来完成多线程并发
    - 线程的调度通过内核来完成
    - 一般情况下应用程序不会直接调用内核线程， 而是采用内核线程向上提供的接口 轻量级进程。我们可以抽象的把轻量级进程理解为线程，每个轻量级进程都会有一个内核线程与之一一对应
    - 缺陷
      - 线程的创建、同步等操作都需要采用系统调用，而系统调用本身代价比较大，需要线程在用户态和内核态之间不断切换
      - 线程的创建需要耗费一定的内核资源，而内核资源本身较少，线程数有限

  - 1:N 用户线程模型
    - 进程与用户线程为1:N的关系
    - 指完全建立在用户态的线程，它的创建、启动、阻塞，停止等操作可以在用户态独立完成，不需要内核线程的帮助
    - 需要自己维护

  - N：M 用户线程与轻量级进程混合模型
    - 轻量级进程作为用户线程和内核线程的桥梁，可以使用内核提供的线程调度功能及处理器映射，此时用户线程的系统调用通过内核线程来完成
    - 一个 轻量级进程 可以对接多个 用户进程，而每个 用户进程 又包含多个 轻量级进程

- 原子类（Atomic）

  - 具有原子操作特征的类
  - 类型

    - 原子更新基本类型
    - 原子更新数组
    - 原子更新引用
    - 原子更新属性

  - 主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作

- CAS

  - CAS 有 3 个操作数
    - 内存值 V
    - 旧的预期值 A
    - 要修改的新值 B
  - 如果内存值 V 和我们的预期值 A 相等，则将内存值修改为 B，操作成功！
  - 如果内存值 V 和我们的预期值 A 不相等，一般也有两种情况：

    - 重试(自旋)
      - 计算内存地址 V、预期值 A 和更新值 B
      - 比较 V 和 A，相等则将变量更新为 B，否则进行自选，重新走一遍这两个步骤
    - 什么都不做，ZAS 失败

  - ABA 问题：待修改变量可能经过多次更新，但最终与预期值一致，但线程无法感知修改过程
    - 解决 ABA 问题：使用 JDK 给我们提供的 AtomicStampedReference 和 AtomicMarkableReference 类
      - AtomicStampedReference
        - 为这个对象提供了一个 stamp 版本，并且这个版本如果被修改了，是自动更新的
      - AtomicMarkableReference
        - 为这个对象提供了 mark 标志，并且这个标志如果被修改了，是自动更新的
  - 执行开销
    - CAS 机制如果 expect 和 V 长时间都不一致，会进行自旋操作（即不断的重试），这会给 CPU 带来非常大的执行开销
    - CAS 机制只能保证一个临界变量的原子操作 ，当操作涉及多个共享变量时 CAS 无效

- 锁

  - 悲观锁：每次在拿数据的时候都会上锁
  - 乐观锁：在更新的时候会判断一下在此期间别人有没有去更新这个数据
    - 实现：
      - 版本号机制
      - CAS

- AQS

  - 用来构建锁和同步器的框架
  - 原理概览
    - 如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态
    - 如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中
      - CLH 队列是一个双向链表，AQS 是将每条请求共享资源的线程封装成一个 CLH 的一个结点（Node）来实现锁的分配
      - 使用一个 int 成员变量来表示同步状态，使用 volatile 修饰保证线程可见性；使用 CAS 对该同步状态进行原子操作实现对其值的修改
  - 对资源的共享方式
    - Exclusive（独占）：只有一个线程能执行，如 ReentrantLock(state 初始化为 0, state+1/-1)
      - 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁
      - 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的
    - Share（共享）：多个线程可同时执行，如 CountDownLatch（state 也初始化为 N， countDown 时 state-1）；Semaphore 信号量（state 为一组 许可（permit），操作时首先要获取到许可，才能进行操作，操作完成后需要释放许可。如果没有获取许可，则阻塞到有许可被释放）
  - 自定义同步器一般的方式
    - 使用者继承 AbstractQueuedSynchronizer 并重写指定的方法
      - isHeldExclusively()//该线程是否正在独占资源。只有用到 condition 才需要去实现它。
      - tryAcquire(int)//独占方式。尝试获取资源，成功则返回 true，失败则返回 false。
      - tryRelease(int)//独占方式。尝试释放资源，成功则返回 true，失败则返回 false。
      - tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
      - tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回 true，失败则返回 false。
    - 将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法

- List、Set、Map

  - List(对付顺序的好帮手)： 存储的元素是有序的、可重复的
  - Set(注重独一无二的性质): 存储的元素是无序的、不可重复的
  - Map(用 Key 来搜索的专家): 使用键值对（kye-value）存储

- HashMap、HashTable、ConcurrentHashMap

  - HashMap：数组+链表/红黑树
  - HashTable：数组+链表；线程安全
  - ConcurrentHashMap：线程安全
  - 首先获得对应的 Segment 的锁； Segment 数组 + HashEntry 数组 + 链表
  - 只锁定当前链表或红黑二叉树的首节点； Node 数组 + 链表 / 红黑树

- ArrayList、LinkedList；ArrayList 扩容

  - Arraylist 基于数组， LinkedList 基于双向链表
  - 都是不保证线程安全
  - ArrayList 扩容
    - 新容量更新为 max(最小需要容量, 旧容量的 1.5 倍)
    - 新容量大于 MAX_ARRAY_SIZE（Integer.MAX_VALUE - 8）
      - 如果最小需要容量大于 MAX_ARRAY_SIZE，新容量为 Integer.MAX_VALUE
      - 否则，新容量为 Integer.MAX_ARRAY_SIZE
    - 元素 copy
      - System.arraycopy()，支持从制定位置开始的复制
      - Arrays.copyOf()，支持指定复制长度
    - 在 add 大量元素之前用 ensureCapacity 方法，以减少增量重新分配的次数

- CopyOnWriteArrayList

  - 写时复制操作，写操作加锁
    - 获取 ReentrantLock 锁
    - 复制数组
    - 添加元素到新的数组
    - 使用新的数组，将原数组进行替换
    - 解锁
  - 读数据
    - 直接读，不需要加锁

- Cookie 与 Session

  - cookie
    - 为了辨别用户身份，暂存在用户本地的信息
  - Session
    - 服务端记录客户端访问状态的机制

- Java 序列化

  - 将对象写入到 IO 流中
  - 如果想让某个变量不被序列化，使用 transient 修饰
  - 序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错
  - 同一对象序列化多次，只有第一次序列化为二进制流，以后都只是保存序列化编号，不会重复序列化。
  - 建议所有可序列化的类加上 serialVersionUID 版本号，方便项目升级

- equals 方法实现

  - “==”比较两个对象的的内存地址
  - equals() 方法是进行内容比较

- static、final、this、super

  - final

    - final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；
    - final 修饰的方法不能被重写；
    - final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象
    - 类中所有的 private 方法都隐式地指定为 final

  - static

    - 修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享; 静态变量 存放在 Java 内存区域的方法区
    - 静态代码块: 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次
    - 静态内部类
      - 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外部类，但是静态内部类却没有
      - 它的创建是不需要依赖外部类的创建；它不能使用任何外部类的非 static 成员变量和方法
      - 静态导包：指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法

  - this

    - 引用类的当前实例

  - super
    - 从子类访问父类的变量和方法
    - 在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。
    - this、super 不能用在 static 方法中

- try-with-resources

  - 适用范围（资源的定义）： 任何实现 java.lang.AutoCloseable 或者``java.io.Closeable` 的对象
  - 关闭资源和 final 的执行顺序： 在 try-with-resources 语句中，任何 catch 或 finally 块在声明的资源关闭后运行

- volatile、synchronized

  - synchronized

    - 作用：解决的是多个线程之间访问资源的同步性，被它修饰的方法或者代码块在任意时刻只能有一个线程执行
    - 使用方式
      - 修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁
      - 修饰静态方法：给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁
      - 修饰代码块：指定加锁对象，对给定对象/类加锁

  - volatile

    - 防止 JVM 的指令重排
    - 保证变量的可见性
      - 指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取

  - synchronized 关键字和 volatile 关键字的区别
    - volatile 关键字是线程同步的轻量级实现，所以 volatile 性能肯定比 synchronized 关键字要好。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块。
    - volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。
    - volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。

- synchronized 和 ReentrantLock 的区别

  - 两者都是可重入锁
    - “可重入锁” 指的是自己可以再次获取自己的内部锁
    - 同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁
  - synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API
    - synchronized 是依赖于 JVM 实现的
    - ReentrantLock 是 JDK 层面实现的
  - ReentrantLock 比 synchronized 增加了一些高级功能
    - 等待可中断
      - ReentrantLock 提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情
    - 可实现公平锁
      - ReentrantLock 可以指定是公平锁还是非公平锁。而 synchronized 只能是非公平锁
    - 可实现选择性通知（锁可以绑定多个条件）
      - synchronized 关键字与 wait()和 notify()/notifyAll()方法相结合可以实现等待/通知机制。
      - ReentrantLock 类当然也可以实现，但是需要借助于 Condition 接口与 newCondition()方法

- ThreadLocal

  - ThreadLocal 类主要解决的就是让每个线程绑定自己的值
  - 每个 Thread 中都具备一个 ThreadLocalMap，而 ThreadLocalMap 可以存储以 ThreadLocal 为 key ，Object 对象为 value 的键值对
  - 最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是 ThreadLocalMap 的封装，传递了变量值
  - ThreadLocalMap
    - hash 冲突
      - 遇到了 key 值相等的数据，直接更新即可；
      - 遇到 key 为 null 的 Entry，直接替换更新；
      - 如果找到 Entry 为 null 的槽位，则将数据放入该槽位中
    - 过期 key 的探测式清理流程
      - 探测式清理
        - 遍历散列数组，从开始位置向后探测清理过期数据，将过期数据的 Entry 设置为 null
        - 碰到未过期的数据则将此数据 rehash 后重新在 table 数组中定位，如果定位的位置已经有了数据，则会将未过期的数据放到最靠近此位置的 Entry=null 的桶中
      - 启发式清理
        - 探测式清理是以当前 Entry 往后清理，遇到值为 null 则结束清理，属于线性探测清理
        - 从制定位置，遍历指定数量的 Extry，遇到过期 Entry，执行过期清理
  - InheritableThreadLocal：父子线程共享
    - InheritableThreadLocal 是在 new Thread 中的 init()方法给赋值的
  - 场景
    - requestId 传递

- 深拷贝、浅拷贝

  - 浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝
  - 深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝

- IO、NIO、BIO、AIO

  - 抽象类
    InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
    OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

  - IO

    - 按照流的流向分，可以分为输入流和输出流；
    - 按照操作单元划分，可以划分为字节流和字符流；
    - 按照流的角色划分为节点流和处理流。

  - BIO(Blocking I/O)

    - 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成

  - NIO (Non-blocking/New I/O)

    - 特性
      - IO 流是阻塞的，NIO 是非阻塞的
        - NIO 允许我们进行非阻塞 IO 操作；比如说，单线程中从通道读取数据到 buffer，同时可以继续做别的事情，当数据读取到 buffer 中后，线程再继续处理数据。写数据也是一样的；
      - Buffer：IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)
        - 在 NIO 厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中
        - 在面向流的 I/O 中·可以将数据直接写入或者将数据直接读到 Stream 对象中
      - Channel（通道）
        - NIO 通过 Channel（通道） 进行读写；通道只能和 Buffer 交互
      - Selector (选择器)
        - 选择器用于使用单个线程处理多个通道
    - 核心组件
      - Buffers
        - 用于和 Channel 交互
        - 内存区缓存，属性：capacity 容量、position 位置、limit 限制
      - Channels 通道
        - FileChannel
        - SocketChannel 和 ServerSocketChannel
        - DatagramChannel
        - Scatter 和 Gather
        - 通道之间的数据传输
      - Selectors
        - 检查一个或多个 NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个 channels

  - AIO (Asynchronous I/O)
    - 异步非阻塞的 IO 模型
    - 基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作

## JVM

- JVM 加载字节码文件

  - 类加载过程
    - 加载
      - 通过全类名获取定义此类的二进制字节流
      - 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
      - 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口
    - 连接
      - 验证
        - 文件格式验证：验证字节码是否符合 Class 文件格式规范，如版本号，常量类型
        - 元数据验证：对字节码进行语义分析，如类是否有父类，是否继承了不允许继承的类
        - 字节码验证：通过数据流和控制流分析，确认程序语义合法、符合逻辑
        - 符号引用验证：确保解析缓解能正确执行
      - 准备
        - 为 static 类变量分配内存并设置类变量初始值的阶段
      - 解析
        - 将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行
    - 初始化
      - 执行类构造器 clinit ()方法的过程
        - new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时
        - 对类进行反射调用时，如果类没初始化，需要触发其初始化
        - 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化
    - 卸载
      - 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。
      - 该类没有在其他任何地方被引用
      - 该类的类加载器的实例已被 GC

- 类加载器

  - BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由 C++实现，负责加载 %JAVA_HOME%/lib 目录下的 jar 包和类或者或被 -Xbootclasspath 参数指定的路径中的所有类
  - ExtensionClassLoader(扩展类加载器) ：主要负责加载目录 %JRE_HOME%/lib/ext 目录下的 jar 包和类，或被 java.ext.dirs 系统变量所指定的路径下的 jar 包
  - AppClassLoader(应用程序类加载器) :面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类
  - 自定义类加载器：除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自 java.lang.ClassLoader。如果我们要自定义自己的类加载器，很明显需要继承 ClassLoader

  - 双亲委派模型

    - 加载的时候，首先会把该请求委派该父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理
    - 当父类加载器为 null 时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器

- JVM 内存模型

  - 线程私有
    - 程序计数器：用于读取指令
    - 虚拟机栈：Java 方法执行的内存模型
    - 本地方法栈：Native 方法执行的内存模型
  - 线程共享
    - 堆：存放对象实例，几乎所有的对象实例以及数组都在这里分配内存
      - 细分：
        - Eden -> s0 -> s1 -> 老年代
    - 方法区：存储已被虚拟机加载的类信息、常量、静态变量
      - 替换为元空间：使用的是直接内存
    - 直接内存：本机直接内存
      - 使用：NIO

- 对象的创建

  - 类加载检查
    - 在常量池中定位到这个类的符号引用， 如果没有，那必须先执行相应的类加载过程
    - 分配内存
      - 分配方式
        - 指针碰撞：标记-压缩算法下，没有内存碎片，根据要分配的大小，移动未使用内存的指针
        - 空闲列表：标记-清除算法下，有内存碎片，在空闲列表中找到大小符合的内存快分配
      - 并发问题
        - CAS+重试
        - TLAB：为每一个线程预先在 Eden 区分配一块儿内存，优先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配
    - 初始化零值
    - 设置对象头
    - 执行 init

- 引用

  - 强引用：垃圾回收器绝不会回收它
  - 软引用：如果内存空间不足了，就会回收这些对象的内存，可以和一个引用队列（ReferenceQueue）联合使用
  - 弱引用：一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存，可以和一个引用队列（ReferenceQueue）联合使用
  - 虚引用：如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收，必须和一个引用队列（ReferenceQueue）联合使用

- GCROOT

  - 用于可达性分析
  - 类型
    - 虚拟机栈(栈帧中的本地变量表)中引用的对象
    - 本地方法栈(Native 方法)中引用的对象
    - 方法区中类静态属性引用的对象
    - 方法区中常量引用的对象

- 对象死亡判断

  - 引用计数
  - 可达性分析：当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的

- JVM GC 及算法

  - 标记-清除
    - 标记之后，直接对可回收对象回收
    - 会产生内存碎片
  - 复制
    - 将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉
  - 标记-整理算法
    - 标记之后，让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存
  - 分代收集算法
    - 根据各个年代的特点选择合适的垃圾收集算法
    - 新生代：每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集
    - 老年代：对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集

- 垃圾回收器

  - Serial 收集器
    - 只会使用一条垃圾收集线程去完成垃圾收集工作，在进行垃圾收集工作的时候必须暂停其他所有的工作线程
    - 新生代采用复制算法，老年代采用标记-整理算法
  - ParNew 收集器
    - 使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样
    - 新生代采用复制算法，老年代采用标记-整理算法
    - 能与 CMS 收集器配合
  - Parallel Scavenge 收集器
    - 关注点是吞吐量（高效率的利用 CPU）
    - 新生代采用复制算法，老年代采用标记-整理算法
  - Serial Old 收集器
    - Serial 收集器的老年代版本，它同样是一个单线程收集器
    - 作为 CMS 收集器的后备方案
  - Parallel Old 收集器
    - Parallel Scavenge 收集器的老年代版本
    - 使用多线程和“标记-整理”算法
  - CMS
    - 关注点更多的是用户线程的停顿时间（提高用户体验），垃圾收集线程与用户线程同时工作
    - 标记-清除
      - 初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
      - 并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
      - 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
      - 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。
  - G1
    - G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region
    - 特点
      - 并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
      - 分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
      - 空间整合：与 CMS 的“标记--清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。
      - 可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。
    - 过程
      - 初始标记
      - 并发标记
      - 最终标记
      - 筛选回收

- 什么情况出现 Full GC、Young GC

  - young GC

    - Eden 区的空间耗尽了

  - Full GC

    - 发生 Young GC 之前进行检查， 可能升入老年代的对象大小，可能超过了老年代当前可用内存空间
    - 执行 Young GC 之后有一批对象需要放入老年代，此时老年代就是没有足够的内存空间存放这些对象
    - 老年代内存使用率超过了一定比率，也要直接触发 Old GC
    - System.gc()，heap dump 带 GC,其默认都是触发 full GC

## Spring IOC && AOP

### IOC

- 控制领域对象的创建以及管理
- 例如：现有类 A 依赖于类 B
  - 传统的开发方式 ：往往是在类 A 中手动通过 new 关键字来 new 一个 B 的对象出来
  - 使用 IoC 思想的开发方式 ：不通过 new 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面过去即可
- 优点
  - 对象之间的耦合度或者说依赖程度降低
  - 资源变的容易管理；比如你用 Spring 容器提供的话很容易就可以实现一个单例

### AOP

- 面向切面编程，AOP 是 OOP（面向对象编程）的一种延续
- 在不改变原有业务逻辑的情况下，增强横切逻辑代码，根本上解耦合，避免横切逻辑代码重复

## 系统架构

- 代理模式

  - 静态代理
    - 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件
    - 静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改
    - 步骤
      - 定义一个接口及其实现类；
      - 创建一个代理类同样实现这个接口
      - 将目标对象注注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。
  - 动态代理

    - 在运行时动态生成类字节码，并加载到 JVM 中的
    - JDK 动态代理机制

      - 只能代理实现了接口的类

      - 定义一个接口及其实现类；
      - 自定义 InvocationHandler 并重写 invoke 方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；
      - 通过 Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h) 方法创建代理对象；

    - CGLIB

      - CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法

      - 定义一个类；
      - 自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似；
      - 通过 Enhancer 类的 create()创建代理类；

- 哪些设计模式能增加系统的可扩展性
  - 工厂模式
  - 代理模式
  - 适配器模式
- 设计模式
- 什么是高内聚低耦合
- 什么情况用接口，什么情况用消息
- AB 两个系统相互依赖，如何解耦
- 如何写一篇技术文档
- 拆分系统与合并系统

## 分布式系统

- 分布式事务
- 分布式锁
- 分布式 Session
- 消息一致性
- 负载均衡
- 正向代理与反向代理
- CDN
- DNS
