# Java

## 基础题目

- Java 线程的状态

  - New：初始状态，线程被构建，没有调用 start 方法
  - RUNABLE：运行状态，Java 将就绪、运行状态的线程统称“运行中”
  - BLOCKED：阻塞，阻塞于锁
  - WATING：等待，当前线程需要等待其他线程
  - TIME_WAITING：超时等待，可以在指定时间内返回
  - TERMINATED：终止状态，线程执行完成

- sleep() 方法和 wait()

  - sleep 方法用于暂停执行，没有释放锁；wait 方法用于线程间交互/通信，释放锁
  - sleep 之后线程自动苏醒；wait 之后，需要等待 notify、notifyAll

- 进程与线程的区别，进程间通信，线程间通信

  - 进程：是系统运行程序的基本单位
  - 线程：操作系统能够进行运算调度的最小单位，多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈
  - 进程间通信

    - 管道/匿名管道

      - 实质：
        - 内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据
        - 一个数据只能被读一次，读出来以后在缓冲区就不复存在了
        - 当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列
      - 限制：
        - 支持单向数据流
        - 只能用于具有亲缘关系的进程之间
        - 缓冲区是有限的
        - 无格式字节流

    - 有名管道

      - 一个路径名与之关联，以有名管道的文件形式存在于文件系统中
      - 只要可以访问该路径，就能够彼此通过有名管道相互通信

    - 信号

      - 信号可以在任何时候发给某一进程，而无需知道该进程的状态
      - 如果该进程当前并未处于执行状态，则该信号就有内核保存起来，直到该进程回复执行并传递给它为止
      - 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程

    - 消息队列

      - 存放在内核中的消息链表，每个消息队列由消息队列标识符表示
      - 消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除
      - 允许一个或多个进程向它写入与读取消息.

    - 共享内存

      - 多个进程可以可以直接读写同一块内存空间
      - 多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥

    - 信号量
      - 意图在于进程间同步
    - socket

  - 线程间通信
    - wait/notify
    - join
    - violate 共享内存
      - 防止 JVM 的指令重排
      - 保证变量在多个线程之间的可见性
    - CountDownLatch
    - 锁机制
    - 管道通信
      - PipedWriter/PipedReader

- Java 线程池

  - Runnable/Callable

    - Runnable: 不会返回结果或抛出检查异常
    - Callable: 可以返回结果或抛出检查异常

  - execute/submit

    - execute：提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否
    - submit：提交需要返回值的任务，线程池会返回一个 Future 类型的对象

  - ThreadPoolExecutor
    - 参数
      - corePoolSize： 最小可以同时运行的线程数量
      - maximumPoolSize： 最大线程数
      - workQueue：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中
      - keepAliveTime：当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程等待的时间超过了 keepAliveTime 才会被回收销毁
      - unit：keepAliveTime 时间单位
      - threadFactory：创建新线程的时候会用到
      - handler：饱和策略
        - 抛出 RejectedExecutionException 来拒绝新任务的处理
        - 处理新任务，直接丢弃掉
        - 丢弃最早的未处理的任务请求
        - 直接在 execute 方法的调用线程中运行被拒绝的任务

- 原子类（Atomic）

  - 主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作

- 锁

  - 悲观锁：每次在拿数据的时候都会上锁
  - 乐观锁：在更新的时候会判断一下在此期间别人有没有去更新这个数据
    - 实现：
      - 版本号机制
      - CAS
    - 缺点
      - ABA
        - compareAndSet：先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值
      - 自旋 CAS 带来 CPU 开销
  - 自旋锁：如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环
    - 优点
      - 线程的状态不会改变，不会使线程进入阻塞状态
    - 缺点
      - 循环等待，消耗 CPU
      - 无法满足等待时间最长的线程优先获取锁
      - 也无法保证可重入性

- List、Set、Map

  - List(对付顺序的好帮手)： 存储的元素是有序的、可重复的
  - Set(注重独一无二的性质): 存储的元素是无序的、不可重复的
  - Map(用 Key 来搜索的专家): 使用键值对（kye-value）存储

- HashMap、HashTable、ConcurrentHashMap

  - HashMap：数组+链表/红黑树
  - HashTable：数组+链表；线程安全
  - ConcurrentHashMap：线程安全
  - 首先获得对应的 Segment 的锁； Segment 数组 + HashEntry 数组 + 链表
  - 只锁定当前链表或红黑二叉树的首节点； Node 数组 + 链表 / 红黑树

- ArrayList、LinkedList；ArrayList 扩容

  - Arraylist 基于数组， LinkedList 基于双向链表
  - 都是不保证线程安全
  - ArrayList 扩容
    - 新容量更新为 max(最小需要容量, 旧容量的 1.5 倍)
    - 新容量大于 MAX_ARRAY_SIZE（Integer.MAX_VALUE - 8）
      - 如果最小需要容量大于 MAX_ARRAY_SIZE，新容量为 Integer.MAX_VALUE
      - 否则，新容量为 Integer.MAX_ARRAY_SIZE
    - 元素 copy
      - System.arraycopy()，支持从制定位置开始的复制
      - Arrays.copyOf()，支持指定复制长度
    - 在 add 大量元素之前用 ensureCapacity 方法，以减少增量重新分配的次数

- CopyOnWriteArrayList

  - 写时复制操作，写操作加锁
    - 获取 ReentrantLock 锁
    - 复制数组
    - 添加元素到新的数组
    - 使用新的数组，将原数组进行替换
    - 解锁
  - 读数据
    - 直接读，不需要加锁

- Cookie 与 Session

  - cookie
    - 为了辨别用户身份，暂存在用户本地的信息
  - Session
    - 服务端记录客户端访问状态的机制

- Java 序列化

  - 将对象写入到 IO 流中
  - 如果想让某个变量不被序列化，使用 transient 修饰
  - 序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错
  - 同一对象序列化多次，只有第一次序列化为二进制流，以后都只是保存序列化编号，不会重复序列化。
  - 建议所有可序列化的类加上 serialVersionUID 版本号，方便项目升级

- equals 方法实现

  - “==”比较两个对象的的内存地址
  - equals() 方法是进行内容比较

- static、final、this、super

  - final

    - final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；
    - final 修饰的方法不能被重写；
    - final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象
    - 类中所有的 private 方法都隐式地指定为 final

  - static

    - 修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享; 静态变量 存放在 Java 内存区域的方法区
    - 静态代码块: 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次
    - 静态内部类
      - 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外部类，但是静态内部类却没有
      - 它的创建是不需要依赖外部类的创建；它不能使用任何外部类的非 static 成员变量和方法
      - 静态导包：指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法

  - this

    - 引用类的当前实例

  - super
    - 从子类访问父类的变量和方法
    - 在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。
    - this、super 不能用在 static 方法中

- try-with-resources

  - 适用范围（资源的定义）： 任何实现 java.lang.AutoCloseable 或者``java.io.Closeable` 的对象
  - 关闭资源和 final 的执行顺序： 在 try-with-resources 语句中，任何 catch 或 finally 块在声明的资源关闭后运行

- volatile、synchronized

  - synchronized

    - 作用：解决的是多个线程之间访问资源的同步性，被它修饰的方法或者代码块在任意时刻只能有一个线程执行
    - 使用方式
      - 修饰方法：作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁
      - 修饰静态方法：作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁
      - 修饰代码块：对给定对象/类加锁

  - volatile

- 深拷贝、浅拷贝

  - 浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝
  - 深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝

- IO、NIO、BIO、AIO

  - 抽象类
    InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
    OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

  - IO

    - 按照流的流向分，可以分为输入流和输出流；
    - 按照操作单元划分，可以划分为字节流和字符流；
    - 按照流的角色划分为节点流和处理流。

  - BIO(Blocking I/O)

    - 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成

  - NIO (Non-blocking/New I/O)

    - 面向缓冲区，非阻塞， 有选择器
    - 核心组件
      - Buffers
        - 用于和 Channel 交互
        - 内存区缓存，属性：capacity 容量、position 位置、limit 限制
      - Channels 通道
        - FileChannel
        - SocketChannel 和 ServerSocketChannel
        - DatagramChannel
        - Scatter 和 Gather
        - 通道之间的数据传输
      - Selectors
        - 检查一个或多个 NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个 channels

  - AIO (Asynchronous I/O)

    - 基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作

## JVM

- JVM 加载字节码文件

  - 类加载过程
    - 加载
      - 通过全类名获取定义此类的二进制字节流
      - 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
      - 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口
    - 连接
      - 验证
        - 文件格式验证：验证字节码是否符合 Class 文件格式规范，如版本号，常量类型
        - 元数据验证：对字节码进行语义分析，如类是否有父类，是否继承了不允许继承的类
        - 字节码验证：通过数据流和控制流分析，确认程序语义合法、符合逻辑
        - 符号引用验证：确保解析缓解能正确执行
      - 准备
        - 为 static 类变量分配内存并设置类变量初始值的阶段
      - 解析
        - 将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行
    - 初始化
      - 执行类构造器 clinit ()方法的过程
        - new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时
        - 对类进行反射调用时，如果类没初始化，需要触发其初始化
        - 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化
    - 卸载
      - 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。
      - 该类没有在其他任何地方被引用
      - 该类的类加载器的实例已被 GC

- 类加载器

  - BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由 C++实现，负责加载 %JAVA_HOME%/lib 目录下的 jar 包和类或者或被 -Xbootclasspath 参数指定的路径中的所有类
  - ExtensionClassLoader(扩展类加载器) ：主要负责加载目录 %JRE_HOME%/lib/ext 目录下的 jar 包和类，或被 java.ext.dirs 系统变量所指定的路径下的 jar 包
  - AppClassLoader(应用程序类加载器) :面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类
  - 自定义类加载器：除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自 java.lang.ClassLoader。如果我们要自定义自己的类加载器，很明显需要继承 ClassLoader

  - 双亲委派模型

    - 加载的时候，首先会把该请求委派该父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理
    - 当父类加载器为 null 时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器

- JVM 内存模型

  - 线程私有
    - 程序计数器：用于读取指令
    - 虚拟机栈：Java 方法执行的内存模型
    - 本地方法栈：Native 方法执行的内存模型
  - 线程共享
    - 堆：存放对象实例，几乎所有的对象实例以及数组都在这里分配内存
      - 细分：
        - Eden -> s0 -> s1 -> 老年代
    - 方法区：存储已被虚拟机加载的类信息、常量、静态变量
      - 替换为元空间：使用的是直接内存
    - 直接内存：本机直接内存
      - 使用：NIO

- 对象的创建

  - 类加载检查
    - 在常量池中定位到这个类的符号引用， 如果没有，那必须先执行相应的类加载过程
    - 分配内存
      - 分配方式
        - 指针碰撞：标记-压缩算法下，没有内存碎片，根据要分配的大小，移动未使用内存的指针
        - 空闲列表：标记-清除算法下，有内存碎片，在空闲列表中找到大小符合的内存快分配
      - 并发问题
        - CAS+重试
        - TLAB：为每一个线程预先在 Eden 区分配一块儿内存，优先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配
    - 初始化零值
    - 设置对象头
    - 执行 init

- GCROOT

  - 用于可达性分析
  - 类型
    - 虚拟机栈(栈帧中的本地变量表)中引用的对象
    - 本地方法栈(Native 方法)中引用的对象
    - 方法区中类静态属性引用的对象
    - 方法区中常量引用的对象

- JVM GC 及算法

  - 标记-清除
    - 标记之后，直接对可回收对象回收
    - 会产生内存碎片
  - 复制
    - 将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉
  - 标记-整理算法
    - 标记之后，让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存
  - 分代收集算法
    - 根据各个年代的特点选择合适的垃圾收集算法
    - 新生代：每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集
    - 老年代：对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集

- 什么情况出现 Full GC、Young GC

  - young GC

    - Eden 区的空间耗尽了

  - Full GC

    - 发生 Young GC 之前进行检查， 可能升入老年代的对象大小，可能超过了老年代当前可用内存空间
    - 执行 Young GC 之后有一批对象需要放入老年代，此时老年代就是没有足够的内存空间存放这些对象
    - 老年代内存使用率超过了一定比率，也要直接触发 Old GC
    - System.gc()，heap dump 带 GC,其默认都是触发 full GC

## 技术深度

- HTTP 协议
- TCP 协议
- 一致性 Hash
- HTTP 连接池
- 数据库连接池
  - 避免了数据库连接初始化和释放过程的时间开销，从而缩减了系统整体响应时间

## 技术框架

- Netty
- Spring IOC
  - 将对象的控制权（创建、管理）交有 IoC 容器去管理
- Spring AOP
- Zookeeper
- rabbitMQ

## 系统架构

- 代理模式

  - 静态代理
    - 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件
    - 静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改
    - 步骤
      - 定义一个接口及其实现类；
      - 创建一个代理类同样实现这个接口
      - 将目标对象注注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。
  - 动态代理

    - 在运行时动态生成类字节码，并加载到 JVM 中的
    - JDK 动态代理机制

      - 只能代理实现了接口的类

      - 定义一个接口及其实现类；
      - 自定义 InvocationHandler 并重写 invoke 方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；
      - 通过 Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h) 方法创建代理对象；

    - CGLIB

      - CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法

      - 定义一个类；
      - 自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似；
      - 通过 Enhancer 类的 create()创建代理类；

- 哪些设计模式能增加系统的可扩展性
  - 工厂模式
  - 代理模式
  - 适配器模式
- 设计模式
- 什么是高内聚低耦合
- 什么情况用接口，什么情况用消息
- AB 两个系统相互依赖，如何解耦
- 如何写一篇技术文档
- 拆分系统与合并系统

## 分布式系统

- 分布式事务
- 分布式锁
- 分布式 Session
- 消息一致性
- 负载均衡
- 正向代理与反向代理
- CDN
- DNS

