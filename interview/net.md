# net

## OSI

### 应用层

- 通过应用进程间的交互来完成特定网络应用，应用层协议定义的是应用进间的通信和交互的规则，如：HTTP 协议、邮件协议 SMTP、域名系统 DNS

### 传输层

- 负责向不同机器进程之间的通信提供通用的数据传输服务
- 协议
  - TCP
  - UDP

### 网络层

- 选择合适的网间路由和交换结点，确保数据及时传送
- 网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送

### 数据链路层

- 将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧；每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）
- MTU 最大传送单元。控制帧的数据部分的的长度上限

### 物理层

- 电信号与数字信号的转换

## 三次握手

### 握手过程

- 客户端–发送带有 SYN 标志,、seq=x 的数据包–一次握手–服务端， 客户端进入 SYN-SENT 状态
- 服务端–发送带有 SYN/ACK 标志、ack=x+1、seq=y 的数据包–二次握手–客户端，服务端从 LISTEN 进入 SYN-RCVD 状态
- 客户端–发送带有带有 ACK 标志、ack=y+1，seq=x+1 的数据包–三次握手–服务端，客户端、服务端进入 ESTABLISHED 状态

### 为什么要三次握手

- 双方确认自己与对方的发送与接收是正常的
  - 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常
  - 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常
  - 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常
- 防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误
  - 客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，客户端重新建立连接完成传输之后，滞留的那一次请求连接，到达了服务器，两次握手的机制将会让客户端和服务器再次建立连接

### 第 2 次握手传回了 ACK，为什么还要传回 SYN

- 接收端传回发送端所发送的 ACK 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的
- 回传 SYN 则是为了建立并确认从服务端到客户端的通信

## 四次挥手

### 挥手过程

- 客户端-发送一个 FIN、seq=u，用来关闭客户端到服务器的数据传送，客户端进入 FIN-WAIT-1 状态
- 服务器-收到这个 FIN，它返回一个 ACK=1，ack=u+1，带上自己的序列号 seq=v。服务端进入 CLOSE-WAIT 状态
- 客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态
- 服务器-关闭与客户端的连接，发送 FIN=1，ack=u+1 给客户端，服务端进入 LAST-ACK 状态
- 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是 seq=u+1，客户端进入 TIME-WAIT 状态；经过 2\*MSL（最长报文段寿命）的时间后，才进入 CLOSED 状态
- 服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态

### 为什么客户端最后还要等待 2MSL

- 保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失
- 防止已经失效的连接请求报文段
  - 客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文

### 为什么建立连接是三次握手，关闭连接确是四次挥手呢

- 建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端
- 而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次

### 如果已经建立了连接，但是客户端突然出现故障了怎么办

- TCP 还设有一个保活计时器，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时
- 若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 秒发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接

## TCP 协议如何保证可靠传输

- 应用数据被分割成 TCP 认为最适合发送的数据块
- TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层
- 校验和
  - TCP 将保持它首部和数据的检验和， 检测数据在传输过程中的任何变化
- TCP 的接收端会丢弃重复的数据
- 流量控制
  - TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据
  - 当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失
  - TCP 使用的流量控制协议是可变大小的滑动窗口协议
- 拥塞控制
  - 当网络拥塞时，减少数据的发送
- ARQ 协议
  - 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组
- 超时重传
  - 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

### ARQ 协议（自动重传请求）

- 数据链路层和传输层的错误纠正协议之一，通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送
- 停止等待 ARQ 协议
  - 每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组
  - 若接收方收到重复分组，就丢弃该分组，但同时还要发送确认
  - 缺点： 信道利用率低，等待时间长
    - 超时重传
      - 每发送完一个分组需要设置一个超时计时器，只要超过一段时间仍然没有收到确认，就重传前面发送过的分组
    - 确认丢失
      - 确认消息在传输过程丢失，数据包重传
    - 确认迟到
      - 确认消息在传输过程中迟到，数据包重传
- 连续 ARQ 协议
  - 发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认
  - 接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了
  - 缺点
    - 不能向发送方反映出接收方已经正确收到的所有分组的信息
    - 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息

### 滑动窗口流量控制

- 流量控制是为了控制发送方发送速率，保证接收方来得及接收
- 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据

### 拥塞控制

- TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量，拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个
- TCP 的拥塞控制采用了四种算法，即 慢开始 、 拥塞避免 、快重传 和 快恢复
  - 慢开始：由小到大逐渐增大发送窗口
  - 拥塞避免：每经过一个往返时间 RTT 就把发送放的拥塞窗口加 1
  - 快重传与快恢复
    - 没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送
    - 有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段，不会因为重传时要求的暂停被耽误

## Cookie 的作用是什么?和 Session 有什么区别

- Cookie 一般用来保存用户信息，保存在客户端
- Session 的主要作用就是通过服务端记录用户的状态，保存在服务端

## HTTP 和 HTTPS 的区别

- 端口
  - HTTP 的 URL 由 `http://` 起始且默认使用端口 80，而 HTTPS 的 URL 由 `https://` 起始且默认使用端口 443
- 安全性和资源消耗
  - HTTP 协议运行在 TCP 之上，所有传输的内容都是明文
  - HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密

## HTTP 长连接、短连接究竟是什么

### HTTP 协议与 TCP/IP 协议的关系

- HTTP 的长连接和短连接本质上是 TCP 长连接和短连接
- HTTP 属于应用层协议，在传输层使用 TCP 协议，在网络层使用 IP 协议

### 什么是长连接、短连接

- 短链接
  - 每次访问资源，浏览器就会重新建立一个 HTTP 会话
- 长连接
  - 客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接
  - Keep-Alive 不会永久保持连接，它有一个保持时间

### TCP 长连接

- 连接并不会主动关闭，后续的读写操作会继续使用这个连接
- TCP 的保活功能
